sourceSets.main.java.srcDirs = ["src"]
sourceSets.test.java.srcDirs = ["test"]
sourceSets.test.resources.srcDirs = ["test/resources"]

dependencies{
    testImplementation libraries.junit
    testImplementation aproj(":natives:natives-desktop")
}

apply plugin: "com.badlogicgames.gdx.gdx-jnigen"

file("jni").mkdir()

jnigen{
    sharedLibName = "arc"
    temporaryDir = file("build/target/native").absolutePath
    libsDir = file("libs").absolutePath

    all{
        cppExcludes = ["iosgl/**", "soloud/src/audiosource/ay/**"]
        cppIncludes = ["*.cpp"]
        cIncludes = ["*.c"]
        headerDirs += ["soloud/include"]
        cppIncludes += ["soloud/src/core/**", "soloud/src/audiosource/**", "soloud/src/filter/**"]
        cIncludes += ["soloud/src/core/**", "soloud/src/audiosource/**", "soloud/src/filter/**"]
    }
    add(Linux, x64){
        cppIncludes += ["soloud/src/backend/miniaudio/*.cpp"]
        cppFlags = "-DWITH_MINIAUDIO " + cppFlags
        libraries += " -lpthread"
    }
    add(Windows, x32){
        cppIncludes += ["soloud/src/backend/winmm/*.cpp"]
        cppFlags = "-msse -DWITH_WINMM " + cppFlags
        libraries += " -lwinmm"
    }
    add(Windows, x64){
        cppIncludes += ["soloud/src/backend/winmm/*.cpp"]
        cppFlags = "-msse -DWITH_WINMM " + cppFlags
        libraries += " -lwinmm"
    }
    add(Android){
        linkerFlags += " -llog -lOpenSLES"
        cppIncludes += ["soloud/src/backend/opensles/*.cpp"]
        cppFlags = "-DWITH_OPENSLES " + cppFlags
    }
    add(MacOsX, x64){
        cppIncludes += ["soloud/src/backend/coreaudio/*.cpp"]
        cppFlags = "-DWITH_COREAUDIO " + cppFlags
        libraries += "-Wl,-framework,CoreAudio -Wl,-framework,AudioToolbox"
    }
    add(IOS){
        headerDirs += ["iosgl"]
        cppExcludes = ["soloud/src/audiosource/ay/**"]
        cppIncludes += ["soloud/src/backend/coreaudio/*.cpp", "iosgl/**"]
        cppFlags = "-DWITH_COREAUDIO " + cppFlags
    }
}

task preJni{
    if(!file("csrc/stb_image.h").exists()){
        println "Fetching stb_image source..."
        "curl -o $rootDir/arc-core/csrc/stb_image.h https://raw.githubusercontent.com/nothings/stb/master/stb_image.h".execute().waitFor()
    }

    if(!file("csrc/soloud").exists()){
        println "Fetching soloud source..."
        "git clone https://github.com/jarikomppa/soloud.git $rootDir/arc-core/csrc/soloud --depth 1".execute()
    }

    copy{
        from "csrc/"
        into "jni/"
        include "**"
    }
}

//copies files into the right locations
task postJni{
    doLast{
        copy{
            from "libs/linux64", "libs/windows32", "libs/windows64", "libs/macosx64"
            into "../natives/natives-desktop/libs"
            include "**"
        }

        ["arm64-v8a", "x86", "x86_64", "armeabi-v7a"].each{ p ->
            copy{
                from "libs/$p"
                into "../natives/natives-android/libs/$p/"
                include "**"
            }
        }

        [".tvos", ""].each{ p ->
            copy{
                from "libs/ios32/libarc.a$p"
                into "../natives/natives-ios/libs/"
                include "**"
            }
        }
    }
}

jnigenBuild.dependsOn preJni
jnigenBuild.finalizedBy postJni

/*
if(useParameters){
    compileJava{
        options.compilerArgs << '-parameters'
    }
}

test{
    testLogging{
        exceptionFormat = 'full'
    }
}

buildscript{
    dependencies{
        classpath libraries.jnigen
    }
}

task deleteJniFolder(type: Delete) {
    delete "jni"
    delete "docs"
}

clean.dependsOn(deleteJniFolder)

task natives(dependsOn: [classes, deleteJniFolder]){
    doLast{
        def mac = System.getProperty("os.name").toLowerCase().contains("mac")
        def root =  "$project.rootDir/arc-core"
        def jnidir = "$root/jni"
        def libdir = "$root/libs"

        new NativeCodeGenerator().generate("$root/src", "$root/build/classes/java/main", jnidir, null, null)

        copy{
            include "**"
            from "csrc/"
            into "jni/"
        }

        //download latest version of stb_image directly into jni folder
        "curl -o $jnidir/stb_image.h https://raw.githubusercontent.com/nothings/stb/master/stb_image.h".execute().waitFor()

        BuildTarget[] targets = [
            BuildTarget.newDefaultTarget(BuildTarget.TargetOs.Windows, false),
            BuildTarget.newDefaultTarget(BuildTarget.TargetOs.Windows, true),
            BuildTarget.newDefaultTarget(BuildTarget.TargetOs.Linux, true),
            BuildTarget.newDefaultTarget(BuildTarget.TargetOs.Android, false),
            BuildTarget.newDefaultTarget(BuildTarget.TargetOs.MacOsX, true),
            BuildTarget.newDefaultTarget(BuildTarget.TargetOs.IOS, false).tap{
                headerDirs = ["iosgl"] as String[]
                cppExcludes = []
            }
        ] as BuildTarget[]

        targets.findAll{it.os != BuildTarget.TargetOs.IOS}*.cppExcludes = ["iosgl/**"] as String[]

        def matches = { String path, List<String> pattern ->
            return pattern.find{ path.contains(it) } != null
        }

        new AntScriptGenerator().generate(new BuildConfig("arc", "$root/build", "libs/", jnidir), targets)

        //overwrite incorrect application mkfile
        new File("$jnidir/Application.mk").text = "APP_ABI := all\nAPP_PLATFORM := android-16"

        //set correct memcpy wrap contents...
        if(!mac) file("$jnidir/memcpy_wrap.c").text = file("$rootDir/natives/memcpy_wrap.c").text
        //wrap functions with right version of glibc
        if(!mac) file("$jnidir/build-linux64.xml").text = file("$jnidir/build-linux64.xml").text.replace("-Wl,-wrap,memcpy", "-Wl,-wrap,memcpy,-wrap,pow")

        for(BuildTarget target : targets){
            if((target.os == BuildTarget.TargetOs.IOS || target.os == BuildTarget.TargetOs.MacOsX) != mac) continue

            String buildFileName = "build-" + target.os.toString().toLowerCase() + (target.is64Bit ? "64" : "32") + ".xml"
            BuildExecutor.executeAnt("$jnidir/" + buildFileName, "-Dhas-compiler=true -Drelease=true clean postcompile")
        }

        new File(libdir).eachFileRecurse{ file ->
            if(!file.path.contains("ios") && !file.path.contains("mac")){
                "strip ${file.absolutePath}".execute().waitFor()
            }
        }

        new File(libdir).eachFileRecurse{ target ->
            if(!target.isDirectory() && matches(target.path, ["windows", "mac", "linux"])){
                file("../natives/natives-desktop/libs/$target.name").bytes = target.bytes
            }else if(!target.isDirectory() && target.path.contains("ios")){
                file("../natives/natives-ios/libs").mkdirs()
                file("../natives/natives-ios/libs/$target.name").bytes = target.bytes
            }
        }

        copy{
            include{ file -> matches(file.path, ["arm", "x86"]) && !file.path.contains("ios") }
            from "libs/"
            into "../natives/natives-android/libs/"
        }

        if(!project.hasProperty("no-clean")){
            //cleanup
            delete{ delete "libs" }
            delete{ delete "obj" }
            delete{ delete "out" }
            delete{ delete "jni" }

            //delete extra garbage, not sure why it even exists
            delete{
                delete "../libs"
            }
        }
    }
}*/
